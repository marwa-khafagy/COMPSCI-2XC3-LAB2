% latex boilerplate 

\documentclass[12pt]{article}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{tikz}
\usepackage{tikz-cd}
\usepackage{parskip}
\usepackage{subcaption}
\usepackage{verbatim}
\usepackage[section]{placeins}

%=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

\newcommand{\firgureBuffered}[2]
{
    \begin{figure}[ht!]
        \centering
        \includegraphics[width=1\textwidth]{#1}
        \caption{#2}
    \end{figure}
}

\newcommand{\firgureDualBuffered}[2]
{
    \begin{figure}[ht!]
        \begin{subfigure}[t]{.45\textwidth}
            \centering
            \includegraphics[width=1\textwidth]{#1_1.png}
            \caption{First Run.}
        \end{subfigure}\hfill
        \begin{subfigure}[t]{.50\textwidth}
            \centering
            \includegraphics[width=1\textwidth]{#1_2.png}
            \caption{Second Run.}
        \end{subfigure}
    \caption{#2}
    \end{figure}
}

%=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

% Hide Numbers on Sections
\setcounter{secnumdepth}{0}

%=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

\title{COMPSCI 2XC3 Lab 3}
\author{Marwa Khafagy, Om Patel, Alex Eckardt}
\date{February 9, 2023}

\begin{document}

\maketitle

%=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
\newpage
\tableofcontents

%=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
\newpage
\listoffigures


%=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
%
%
%                       EXPERIMENT 1
%
%
%=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
\newpage
\section{Part 1}
\subsection{Experiment 1}

\subsubsection{Graph Class Optimizations}

To squeeze some performance out of the Graph class, especially at larger scales, we do some optimizations.

Firstly, when adding an edge to a node, if we are adding a self-loop, then we only add that to the list once.

The next improvement is memorizing the nodes that contain edges. When we add a node, we mark it in a dictionary as `marked'--IE, we store that this node has an edge on it.

This dictionary's keys can then be used to check for a cycle instead of the adjacency list's-- we don't spend time checking nodes which have no edges if they contribute to a cycle. This change significantly impacts performance, especially on test 8 of this Experiment.

\subsubsection{Test Outlines}

Experiment 1 conducts three types of tests in order to XXX\@. These tests include Proportionality Test, Proportionality Test*, and the Addition Test.

\subsubsection*{Proportionality Test}
The first test, Proportionality, works as follows:

\begin{itemize}
    \item We create a random graph $G$ with constant $V$ nodes and $E$ amount of edges.
    \item We check if $G$ contains a cycle. If so, add to a count.
    \item Repeat above $X$ times, and get the proportion of cycle vs non-cycle.
    \item Repeat this entire process for a range of $E$.
\end{itemize}

\subsubsection*{Proportionality Test*}
The next test, Proportionality Test* follows exactly from Proportionality Test, but does not allow for a definition of $E$. Instead, $E$ is calculated as

\begin{center}
    $E = \frac{V^2 + V}{2}$
\end{center}

This is the maximum number of edges that can be added to an undirected graph, with self loops. This way, we explore the range of all possible number of edge counts.

\subsubsection*{Addition Test}

This test works as follows.

\begin{itemize}
    \item We initialize graph $G$ with $V$ nodes and 0 edges.
    \item We add an edge to $G$.
    \item Repeat this process until $G$ contains a cycle or no more edges can be added to $G$.
    \item When a cycle is found, track how many edges were added to $G$.
    \item After this process is repeated after $X$ trials, we find the average number of edges added to create a cycle.
    \item We also keep track of the minimum and maximum number of edges were added.
    \item Repeat this entire process for a range of $V$.
\end{itemize}

\subsubsection{Tests}

The first test conducted in Experiment 1 is a Proportionality Test*, on 1000 trials on graphs with 5 nodes.

The second test is a Proportionality Test*, on 1000 trials on graphs with 10 nodes.

Next, a Proportionality Test*, on 1000 trials on graphs with 30 nodes.

Afterwards, we perform a regular Proportionality Test with 100 trials on graphs with 100 nodes. We define the max edge count to be 1000. Had we used the Proportionality* Test, we have a max edge count of 5050.

Next we perform our Addition tests.

First we do the test on ranges 0--5, averaging the result between 1000 trials.

Then, we do it on the range 0--100, again averaging the result on 1000 trials.

Penultimately, we perform the Addition Test on the range 0 to 1000, skipping every 10. Here, we only average based on 10 trials.

We then do we perform the Addition Test on the range 0 to 10000, skipping every 500. With 40 trials, to see if anything strange occurs on larger graph sizes.


\subsubsection{Proportionality Test Results and Conclusions}

\FloatBarrier{}
\firgureBuffered{images/exp1_a.png}{Proportionality* Test on graph sizes 0--5, 0--15 Edges}
\firgureBuffered{images/exp1_b.png}{Proportionality* Test on graph sizes 0--10, 0--55 Edges}
\firgureBuffered{images/exp1_c.png}{Proportionality* Test on graph sizes 0--30, 0--465 Edges}
\firgureBuffered{images/exp1_d.png}{Proportionality Test on graph sizes 0--100, 0--1000 Edges}
\FloatBarrier{}

What we can see from the proportionality tests is that eventually we see that the average number of cyclical graphs hits 1.0. This means that, in our trials, after some certain number of edge count, every single graph we created was cyclical.

We can see the ratio of edges we need in the random graph as follows:
\begin{itemize}
    \item Node Count of 5, we need 5 edges to always create a cycle.
    \item Node count of 10, we need 10 edges to always create a cycle.
    \item Node count of 30, we need 27 edges to always create a cycle.
    \item Node count of 100, we need 75 edges to always create a cycle.
\end{itemize}

What we can determine is that if we have a graph of $V$ nodes, if we randomly insert $V$ amount of edges, we guarantee a cycle to be created.

This makes sense if we consider a graph with $V$ nodes and $V$ edges. If we wanted to minimize the number of cycles in this graph, we would make every node connect only to it's neighbours. This way, each node is only ever connected to 2 nodes. If the cycle we create here contains exactly every node, there would only be one cycle in the graph.
Let us name this graph $G^{*}$, the graph with one cycle and $V$ edges.

\FloatBarrier{}
\firgureBuffered{images/exp1_exp1.png}{Example Graphs $V$ nodes and $V$ edges, $G^{*}$}
\FloatBarrier{}

If we were to add a node at random to $G$, we see would would create another cycle. As every node is already connected to every other, we now have two paths to every other node.

Likewise, if we were to remove a node from $G^{*}$, we would be forced to break our cycle. This means that, if we have $V-1$ edges, we are not guaranteed to have a cycle.

What we can conclude is that if we have a graph with $V$ nodes and $V$ edges, we are guaranteed to have a cycle. The disparities that we find in tests 3 and 4 is that, it is astronomically more likely as $V$ increases that we create a cycle before we hit $V$ edges (Think self loop being very easy to create). Had we performed more trials, or create every possible graph, we would see that Tests 3 and 4 would also require $V$ edges to create a cycle, not some number less than $V$.

\subsubsection{Addition Test Results and Conclusions}

\FloatBarrier{}
\firgureBuffered{images/exp1_e.png}{Addition Test on graph sizes 0--5}
\firgureBuffered{images/exp1_f.png}{Addition Test on graph sizes 0--100}
\firgureBuffered{images/exp1_g.png}{Addition Test on graph sizes 0--1000, skipping 10.}
\firgureBuffered{images/exp1_h.png}{Addition Test on graph sizes 0-10000, skipping 500.}
\FloatBarrier{}

What we can conclude here is very similar to the conclusions we made in the proportionality tests.

If we look at the minimum number of edges need to be added to create a cycle, we see that it stays constant at 1. This is very easy to explain, the edge we added connected some node to itself.

If we look at the maximum number of edges needed to be added to create a cycle, we see that it tends to be close but also exactly at $V$. If we look at Test 6, we see that, for x <= 20, x = y; meaning the number of nodes is equal to the number of edges. When we go above, the number of edges added is once again below the node count, as in the 1000 trials, we never create a graph with a cycle as described by graph $G^{*}$ above. Again, had we created every single possible graph with $V$ nodes, we would have seen that this number sticks exactly to x=y.

Obviously, we see that the average number of edges need to create a cycle seems stay in between the maximum and minimum number of edges.

%=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
%
%
%                       EXPERIMENT 2
%
%
%=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
\newpage
\subsection{Experiment 2}

%=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
%
%
%                       EXPERIMENT 2
%
%
%=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
\newpage
\subsection{Executive Summary}


%=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
%
%
%                       EXPERIMENT 3
%
%
%=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
\newpage
\section{Part 2}
\subsection{Experiment3}

%=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
%
%
%                       APPENDIX
%
%
%=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
\newpage
\section{Appendix}

Experiment 1's tests are conducted in experiment1.py.
The function for each test is as follows.
\begin{itemize}
    \item Proportionality Test = proportionality\_test\(\)
    \item Proportionality Test* = max\_proportionality\_test\(\)
    \item Addition Test = edge\_additions\_until\_cycle\_test\(\)
\end{itemize}
$ $
\newline
All the actual tests performed are outlined at the bottom on experiment1.py.

%=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
%=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
%=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

\end{document}