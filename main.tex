% latex boilerplate 

\documentclass[12pt]{article}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{tikz}
\usepackage{tikz-cd}
\usepackage{parskip}
\usepackage{subcaption}
\usepackage{verbatim}
\usepackage[section]{placeins}

%=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

\newcommand{\firgureBuffered}[2]
{
    \begin{figure}[ht!]
        \centering
        \includegraphics[width=1\textwidth]{#1}
        \caption{#2}
    \end{figure}
}

\newcommand{\firgureDualBuffered}[2]
{
    \begin{figure}[ht!]
        \begin{subfigure}[t]{.45\textwidth}
            \centering
            \includegraphics[width=1\textwidth]{#1_1.png}
            \caption{First Run.}
        \end{subfigure}\hfill
        \begin{subfigure}[t]{.50\textwidth}
            \centering
            \includegraphics[width=1\textwidth]{#1_2.png}
            \caption{Second Run.}
        \end{subfigure}
    \caption{#2}
    \end{figure}
}

%=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

% Hide Numbers on Sections
\setcounter{secnumdepth}{0}

%=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

\title{COMPSCI 2XC3 Lab 3}
\author{Marwa Khafagy, Om Patel, Alex Eckardt}
\date{February 9, 2023}

\begin{document}

\maketitle

%=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
\newpage
\tableofcontents

%=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
\newpage
\listoffigures


%=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
%
%
%                       EXPERIMENT 1
%
%
%=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
\newpage
\section{Part 1}
\subsection{Experiment 1}

\subsubsection{Graph Class Optimizations}

To squeeze some performance out of the Graph class, especially at larger scales, we do some optimizations.

Firstly, when adding an edge to a node, if we are adding a self-loop, then we only add that to the list once.

The next improvement is memorizing the nodes that contain edges. When we add a node, we mark it in a dictionary as `marked'--IE, we store that this node has an edge on it.

This dictionary's keys can then be used to check for a cycle instead of the adjacency list's-- we don't spend time checking nodes which have no edges if they contribute to a cycle. This change significantly impacts performance, especially on test 8 of this Experiment.

\subsubsection{Test Outlines}

Experiment 1 conducts three types of tests in order to XXX\@. These tests include Proportionality Test, Proportionality Test*, and the Addition Test.

\subsubsection*{Proportionality Test}
The first test, Proportionality, works as follows:

\begin{itemize}
    \item We create a random graph $G$ with constant $V$ nodes and $E$ amount of edges.
    \item We check if $G$ contains a cycle. If so, add to a count.
    \item Repeat above $X$ times, and get the proportion of cycle vs non-cycle.
    \item Repeat this entire process for a range of $E$.
\end{itemize}

\subsubsection*{Proportionality Test*}
The next test, Proportionality Test* follows exactly from Proportionality Test, but does not allow for a definition of $E$. Instead, $E$ is calculated as

\begin{center}
    $E = \frac{V^2 + V}{2}$
\end{center}

This is the maximum number of edges that can be added to an undirected graph, with self loops. This way, we explore the range of all possible number of edge counts.

\subsubsection*{Addition Test}

This test works as follows.

\begin{itemize}
    \item We initialize graph $G$ with $V$ nodes and 0 edges.
    \item We add an edge to $G$.
    \item Repeat this process until $G$ contains a cycle or no more edges can be added to $G$.
    \item When a cycle is found, track how many edges were added to $G$.
    \item After this process is repeated after $X$ trials, we find the average number of edges added to create a cycle.
    \item We also keep track of the minimum and maximum number of edges were added.
    \item Repeat this entire process for a range of $V$.
\end{itemize}

\subsubsection{Tests}

The first test conducted in Experiment 1 is a Proportionality Test*, on 1000 trials on graphs with 5 nodes.

The second test is a Proportionality Test*, on 1000 trials on graphs with 10 nodes.

Next, a Proportionality Test*, on 1000 trials on graphs with 30 nodes.

Afterwards, we perform a regular Proportionality Test with 100 trials on graphs with 100 nodes. We define the max edge count to be 1000. Had we used the Proportionality* Test, we have a max edge count of 5050.

Next we perform our Addition tests.

First we do the test on ranges 0--5, averaging the result between 1000 trials.

Then, we do it on the range 0--100, again averaging the result on 1000 trials.

Penultimately, we perform the Addition Test on the range 0 to 1000, skipping every 10. Here, we only average based on 10 trials.

We then do we perform the Addition Test on the range 0 to 10000, skipping every 500. With 40 trials, to see if anything strange occurs on larger graph sizes.


\subsubsection{Proportionality Test Results and Conclusions}

\FloatBarrier{}
\firgureBuffered{images/experiment1/exp1_a.png}{Proportionality* Test on graph sizes 0--5, 0--15 Edges}
\firgureBuffered{images/experiment1/exp1_b.png}{Proportionality* Test on graph sizes 0--10, 0--55 Edges}
\firgureBuffered{images/experiment1/exp1_c.png}{Proportionality* Test on graph sizes 0--30, 0--465 Edges}
\firgureBuffered{images/experiment1/exp1_d.png}{Proportionality Test on graph sizes 0--100, 0--1000 Edges}
\FloatBarrier{}

What we can see from the proportionality tests is that eventually we see that the average number of cyclical graphs hits 1.0. This means that, in our trials, after some certain number of edge count, every single graph we created was cyclical.

We can see the ratio of edges we need in the random graph as follows:
\begin{itemize}
    \item Node Count of 5, we need 5 edges to always create a cycle.
    \item Node count of 10, we need 10 edges to always create a cycle.
    \item Node count of 30, we need 27 edges to always create a cycle.
    \item Node count of 100, we need 75 edges to always create a cycle.
\end{itemize}

What we can determine is that if we have a graph of $V$ nodes, if we randomly insert $V$ amount of edges, we guarantee a cycle to be created.

This makes sense if we consider a graph with $V$ nodes and $V$ edges. If we wanted to minimize the number of cycles in this graph, we would make every node connect only to it's neighbours. This way, each node is only ever connected to 2 nodes. If the cycle we create here contains exactly every node, there would only be one cycle in the graph.
Let us name this graph $G^{*}$, the graph with one cycle and $V$ edges.

\FloatBarrier{}
\firgureBuffered{images/experiment1/exp1_exp1.png}{Example Graphs $V$ nodes and $V$ edges, $G^{*}$}
\FloatBarrier{}

If we were to add a node at random to $G$, we see would would create another cycle. As every node is already connected to every other, we now have two paths to every other node.

Likewise, if we were to remove a node from $G^{*}$, we would be forced to break our cycle. This means that, if we have $V-1$ edges, we are not guaranteed to have a cycle.

What we can conclude is that if we have a graph with $V$ nodes and $V$ edges, we are guaranteed to have a cycle. The disparities that we find in tests 3 and 4 is that, it is astronomically more likely as $V$ increases that we create a cycle before we hit $V$ edges (Think self loop being very easy to create). Had we performed more trials, or create every possible graph, we would see that Tests 3 and 4 would also require $V$ edges to create a cycle, not some number less than $V$.

\subsubsection{Addition Test Results and Conclusions}

\FloatBarrier{}
\firgureBuffered{images/experiment1/exp1_e.png}{Addition Test on graph sizes 0--5}
\firgureBuffered{images/experiment1/exp1_f.png}{Addition Test on graph sizes 0--100}
\firgureBuffered{images/experiment1/exp1_g.png}{Addition Test on graph sizes 0--1000, skipping 10.}
\firgureBuffered{images/experiment1/exp1_h.png}{Addition Test on graph sizes 0-10000, skipping 500.}
\FloatBarrier{}

What we can conclude here is very similar to the conclusions we made in the proportionality tests.

If we look at the minimum number of edges need to be added to create a cycle, we see that it stays constant at 1. This is very easy to explain, the edge we added connected some node to itself.

If we look at the maximum number of edges needed to be added to create a cycle, we see that it tends to be close but also exactly at $V$. If we look at Test 6, we see that, for x <= 20, x = y; meaning the number of nodes is equal to the number of edges. When we go above, the number of edges added is once again below the node count, as in the 1000 trials, we never create a graph with a cycle as described by graph $G^{*}$ above. Again, had we created every single possible graph with $V$ nodes, we would have seen that this number sticks exactly to x=y.

Obviously, we see that the average number of edges need to create a cycle seems stay in between the maximum and minimum number of edges.

%=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
%
%
%                       EXPERIMENT 2
%
%
%=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
\newpage
\subsection{Experiment 2}


\subsubsection{Test Outlines}

Experiment 2 performs 2 types of tests, which act almost identically to the tests in Experiment 1.

\subsubsection*{Proportionality Test}
The first test, Proportionality, works as follows:

\begin{itemize}
    \item We create a random graph $G$ with constant $V$ nodes and $E$ amount of edges.
    \item We check if $G$ is connected. If so, add to a count.
    \item Repeat above $X$ times, and get the proportion of connected vs non-connected.
    \item Repeat this entire process for a range of $E$.
\end{itemize}

\subsubsection*{Proportionality Test*}
The next test, Proportionality Test* follows exactly from Proportionality Test, but does not allow for a definition of $E$. Instead, $E$ is calculated as

\begin{center}
    $E = \frac{V^2 + V}{2}$
\end{center}

This is the maximum number of edges that can be added to an undirected graph, with self loops. This way, we explore the range of all possible number of edge counts.

This works best for small graphs, so that the edge count is not extraordinarily high.


\subsubsection{Tests}

As all the tests are proportionality tests, we define the inputs here.

The first test conducted in Experiment 2 is a Proportionality Test*, on 1000 trials on graphs with 5 nodes.

The second test is a Proportionality Test*, on 1000 trials on graphs with 10 nodes.

Next, a Proportionality Test*, on 1000 trials on graphs with 30 nodes.

Afterwards, we perform a regular Proportionality Test with 100 trials on graphs with 100 nodes. We define the max edge count to be 1000. Had we used the Proportionality* Test, we have a max edge count of 5050.

And finally, we do a tests that show us how the connectivity falls off based on, same as in Experiment 1, $V$ nodes and $V$ edges. 
The graph size will be 1000 nodes. The maximum number of edges will be 100\% of the number of nodes (1000 edges); doing only the edges that are a multiple of 5. We do 100 trials per edge count.


\subsubsection{Proportionality Test Results and Conclusions}

%=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
%
%
%                       EXPERIMENT 2
%
%
%=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
\newpage
\subsection{Executive Summary}


%=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
%
%
%                       EXPERIMENT 3
%
%
%=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
\newpage
\section{Part 2}
\subsection{Experiment3}

%=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
%
%
%                       EXPERIMENT 3
%
%
%=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
\newpage
\subsection{The Independent Set Problem}
In this experiment, we performed tests to empircally find the relationship between the maximum 
independent set (MIS) and the minimum vertex cover (MVC) of an undirected graph.

\subsubsection{Test Outlines}

In the first test we ran, we graphed the sum of the cardinalities of MIS and MVC.

This first test, works as follows:

\begin{itemize}
    \item We create a random graph $G$ with $n$ nodes and some randomly generated edges $E$
    \item We find the cardinality of MIS
    \item We find the cardinality of MVC
    \item We sum these two cardinalities 
    \item Repeat this process for $x$ amount of trials (we chose 5 trials)
    \item We average the sum of these two cardinalities and plot it 
    \item Repeat this entire process for a range of graph sizes (we chose to go up to graphs with 25 nodes)
\end{itemize}

In the second test we ran, we graphed cardinalities of MIS, MVC and the complement of MVC.

This second test, works as follows:

\begin{itemize}
    \item We create a random graph $G$ with $n$ nodes and some randomly generated edges $E$
    \item We find the cardinality of MIS
    \item We find the cardinality of MVC
    \item We check if the complement of MVC is an independent set, raising an exception if it is not
    \item Repeat this process for $x$ amount of trials (we chose 5 trials)
    \item We plot the averages of cardinality of MIS, MVC, and we also plot the cardinality of the complement of MVC
    \item Repeat this entire process for a range of graph sizes (we chose to go up to graphs with 25 nodes)
\end{itemize}

In the third test we ran, we graphed cardinalities of MIS, MVC and the complement of MIS.

This second test, works as follows:

\begin{itemize}
    \item We create a random graph $G$ with $n$ nodes and some randomly generated edges $E$
    \item We find the cardinality of MIS
    \item We find the cardinality of MVC
    \item We check if the complement of MIS is a vertex cover, raising an exception if it is not
    \item Repeat this process for $x$ amount of trials (we chose 5 trials)
    \item We plot the averages of cardinality of MIS, MVC, and we also plot the cardinality of the complement of MIS
    \item Repeat this entire process for a range of graph sizes (we chose to go up to graphs with 25 nodes)
\end{itemize}


\subsubsection{Test Results}

\FloatBarrier{}
\firgureBuffered{images/IndSet/Figure_1.png}{Test 1}
\firgureBuffered{images/IndSet/Figure_2.png}{Test 2}
\firgureBuffered{images/IndSet/Figure_3.png}{Test 3}
\FloatBarrier{}

\subsubsection{Conclusions}
Upon performing the first test, we found that the sum of the cardinalities of MIS and MVC are always equal
to the number of nodes in the graph. 

Through the second test we found that the complement of MVC has the same cardinality of a MIS, and is an independent set.

Through the third test we found that the complement of MIS has the same cardinality of a MVC, and is a vertex cover.

In conclusion, these three tests show empircally that the complement of a MVC is a MIS, and vise versa. Thus, given a MIS, 
one can find a MIS (and vise versa). We also note that there may exists more than one MIS/MVC for a given graph, so checking 
to see if the complement of MVC is equal to a given MIS may return false. 



%=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
%
%
%                       APPENDIX
%
%
%=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
\newpage
\section{Appendix}

Experiment 1's tests are conducted in experiment1.py.
The function for each test is as follows.
\begin{itemize}
    \item Proportionality Test = proportionality\_test\(\)
    \item Proportionality Test* = max\_proportionality\_test\(\)
    \item Addition Test = edge\_additions\_until\_cycle\_test\(\)
\end{itemize}
$ $
\newline
All the actual tests performed are outlined at the bottom on experiment1.py.
\newline
$ $
\newline

Experiment 2's tests are conducted in experiment2.py.
The function for each test is as follows.
\begin{itemize}
    \item Proportionality Test = proportionality\_test\(\)
    \item Proportionality Test* = max\_proportionality\_test\(\)
\end{itemize}
$ $
\newline
All the actual tests performed are outlined at the bottom on experiment2.py.



%=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
%=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
%=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

\end{document}